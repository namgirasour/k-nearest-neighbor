# -*- coding: utf-8 -*-
"""ML_HW1_Exercise 1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zKcTuNj5wW6vSnwUSBoEHc1MiJaUeOPt
"""

import pandas as pd
import numpy as np
#from numpy import genfromtxt
#import matplotlib.pyplot as plt
import math
from math import sqrt
import csv
#import operator

train_set = pd.read_csv('/content/mnist_train.csv', header=None )
test_set = pd.read_csv('/content/mnist_test.csv', header=None )

train_set

y_train= np.array(train_set.iloc [:,0]) #[:1000]
x_train= np.array(train_set.iloc [::,1:]) #[:1000]
print(len(x_train))
print(len(y_train))

y_test= np.array(test_set.iloc [:,0]) #[:100]
x_test= np.array(test_set.iloc [::,1:]) #[:100]
print(len(x_test))
print(len(y_test))
print(len(x_train))
print(len(y_train))

y_test

x_test

x_train

y_train

# def euc_dist(x, y):
#   #print(x,y)
#   return sum(
#       [(x_i - y_i) ** 2 
#        for x_i, y_i in zip(x, y)
#        ]
#        ) ** (0.5)

# def euc_dist(x, y):
#   return sum(
#       [(x_i - y_i) ** 2 for x_i, y_i in zip(x,y)]
#   ) ** (0.5)

#return np.sqrt(np.sum(np.subtract(x1, x2)**2)) #euclidean distance
#def euc_dist(row1, row2):
    #distance = 0
    #for i in range(row1-1):
        #distance += (row1[i] - row2[i])**2
    #return sqrt(distance)
def euc_dist(x1, x2):
    return np.sqrt(np.sum(np.subtract(x1, x2)** 2))

def get_training_distance(x_train, test_sample):
  # result = []
  
  # for train_sample in x_train:
  #   r = euc_dist(test_sample, train_sample)
  #   print(f"r={r} train_sample={train_sample} test_sample={test_sample}")
  #   result.append(r)
  # return result
  return [euc_dist(train_sample, test_sample) for train_sample in x_train] #calculate distances of vectors in training data to test data

def most_frequent(l):
  return max(l, key=l.count)

def knn(x_train, y_train, x_test, k):
  cf = np.zeros((10,10)) # initialize confusion matrix
  y_pred = [] #predicted labels
  #print(x_test)
  #for test_sample_idx, test_sample in range(len(x_test)):
  for i in range(len(x_test)):
    test_sample = x_test[i]
    
    #row = x_test.iloc[index]
    training_distances = get_training_distance(x_train, test_sample)

    distances = [[y_train[i], training_distances[i]] for i in range(len(x_train))]

    sort_label_distance = [
        pair[0]
        for pair in sorted(
            distances,
            key=lambda x: x[1] 
        )
    ][:k]
    # sk = [
    #     y_train[idx]
    #     for idx in sort_distance[:k]
    # ]
    #print(f'Point is {y_test[test_sample_idx]} and we guessed {sk}')
    #print(sk)
    #print(sort_distance)
    #y_sample = 10
    #y_pred.append(y_sample)
    # for i in range(len(test_set))
    # neighbors = knn(x_train, y_train, x_test[i], k)
    # result = y_pred
    



    # print(sort_label_distance)

    top_sk = most_frequent(sort_label_distance)
    
    update_confusion_matrix(top_sk, y_test[i])
    y_pred.append(top_sk)
  return y_pred

cf = np.zeros((10,10))
def update_confusion_matrix(prediction,actual):
  cf[actual,prediction] +=1
  # actual_label = y_train
  # predict_label = y_pred
    # return ((y_pred,actual_label) += 1)

def main():
  # test k=3
  y_pred_k1 = knn(x_train, y_train, x_test, 1)
  accuracy1 = sum([
      int(y_pred_i == y_test_i)
      for y_pred_i, y_test_i
      in zip(y_pred_k1, y_test)
  ]) / len(y_test)
  # print(f'Predicted Labels3: {y_pred_k3}')
  print(f'Accuracy1: {accuracy1 * 100}%')
  print(f'Confusion Matrix1: \n{cf}')

  # test k=5
  y_pred_k5 = knn(x_train, y_train, x_test, 5)
  accuracy5 = sum([
      int(y_pred_i == y_test_i)
      for y_pred_i, y_test_i
      in zip(y_pred_k5, y_test)
  ]) / len(y_test)
  # print(f'Predicted Labels5: {y_pred_k5}')
  print(f'Accuracy5: {accuracy5 * 100}%')
  print(f'Confusion Matrix5: \n{cf}')

    y_pred_k7 = knn(x_train, y_train, x_test, 7)
  accuracy7 = sum([
      int(y_pred_i == y_test_i)
      for y_pred_i, y_test_i
      in zip(y_pred_k7, y_test)
  ]) / len(y_test)
  print(f'Accuracy7: {accuracy7 * 100}%')
  print(f'Confusion Matrix5: \n{cf}')

     # test k=1
  y_pred_k1 = knn(x_train, y_train, x_test, 1)
  accuracy1 = sum([
      int(y_pred_i == y_test_i)
      for y_pred_i, y_test_i
      in zip(y_pred_k1, y_test)
  ]) / len(y_test)
  print(f'Accuracy5: {accuracy1 * 100}%')
  print(f'Confusion Matrix5: \n{cf}')









if __name__ == '__main__':
  main()